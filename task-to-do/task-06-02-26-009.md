# Task 009 - [ELEVE] : AI ML Forecast Edge Function

## Fichier(s) a creer
- `supabase/functions/ai-ml-forecast/index.ts`

## Probleme
CashPilot ne dispose pas de previsions financieres avancees basees sur l'IA avec decomposition tendance/saisonnalite.

## Solution
Creer une Edge Function utilisant Gemini pour generer des previsions de type Prophet/LSTM.

## Code attendu
```typescript
import { serve } from 'https://deno.land/std@0.177.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.39.3';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

const CREDIT_COST = 3;

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    const geminiKey = Deno.env.get('GEMINI_API_KEY');
    if (!geminiKey) throw new Error('GEMINI_API_KEY not configured');

    const supabase = createClient(
      Deno.env.get('SUPABASE_URL')!,
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
    );

    const { userId, months = 12, forecastMonths = 6, dataType = 'revenue' } = await req.json();

    if (!userId) {
      return new Response(
        JSON.stringify({ error: 'Missing userId' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Check credits
    const { data: credits } = await supabase
      .from('user_credits')
      .select('free_credits, paid_credits')
      .eq('user_id', userId)
      .single();

    const availableCredits = (credits?.free_credits || 0) + (credits?.paid_credits || 0);
    if (!credits || availableCredits < CREDIT_COST) {
      return new Response(
        JSON.stringify({ error: 'insufficient_credits' }),
        { status: 402, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Deduct credits
    const freeDeduction = Math.min(credits.free_credits, CREDIT_COST);
    const paidDeduction = CREDIT_COST - freeDeduction;
    await supabase.from('user_credits').update({
      free_credits: credits.free_credits - freeDeduction,
      paid_credits: credits.paid_credits - paidDeduction,
      updated_at: new Date().toISOString()
    }).eq('user_id', userId);

    await supabase.from('credit_transactions').insert([{
      user_id: userId,
      amount: -CREDIT_COST,
      type: 'usage',
      description: 'AI ML Forecast'
    }]);

    // Fetch historical data
    const startDate = new Date();
    startDate.setMonth(startDate.getMonth() - months);

    let historicalData: any[] = [];

    if (dataType === 'revenue' || dataType === 'all') {
      const { data: invoices } = await supabase
        .from('invoices')
        .select('total_ttc, invoice_date, status')
        .eq('user_id', userId)
        .gte('invoice_date', startDate.toISOString())
        .in('status', ['paid', 'sent', 'validated'])
        .order('invoice_date', { ascending: true });

      // Aggregate by month
      const monthlyRevenue: Record<string, number> = {};
      (invoices || []).forEach((inv: any) => {
        const month = inv.invoice_date.substring(0, 7);
        monthlyRevenue[month] = (monthlyRevenue[month] || 0) + (inv.total_ttc || 0);
      });

      historicalData = Object.entries(monthlyRevenue).map(([month, value]) => ({
        month,
        value,
        type: 'revenue'
      }));
    }

    if (dataType === 'expenses' || dataType === 'all') {
      const { data: expenses } = await supabase
        .from('expenses')
        .select('amount, date')
        .eq('user_id', userId)
        .gte('date', startDate.toISOString())
        .order('date', { ascending: true });

      const monthlyExpenses: Record<string, number> = {};
      (expenses || []).forEach((exp: any) => {
        const month = exp.date.substring(0, 7);
        monthlyExpenses[month] = (monthlyExpenses[month] || 0) + (exp.amount || 0);
      });

      const expenseData = Object.entries(monthlyExpenses).map(([month, value]) => ({
        month,
        value,
        type: 'expenses'
      }));

      if (dataType === 'all') {
        historicalData = [...historicalData, ...expenseData];
      } else {
        historicalData = expenseData;
      }
    }

    // Build prompt for Gemini
    const prompt = `Tu es un expert en analyse financiere predictive et en machine learning.

Analyse ces donnees financieres historiques sur ${months} mois et genere des previsions pour les ${forecastMonths} prochains mois.

DONNEES HISTORIQUES (${dataType}):
${JSON.stringify(historicalData, null, 2)}

INSTRUCTIONS:
1. Decompose la serie temporelle en tendance et saisonnalite
2. Identifie les patterns recurrents (mensuels, trimestriels, annuels)
3. Detecte les points d'inflexion ou anomalies
4. Genere des previsions avec intervalles de confiance

Reponds UNIQUEMENT en JSON valide avec cette structure exacte:
{
  "forecasts": [
    { "month": "YYYY-MM", "predicted": 0, "lower_80": 0, "upper_80": 0, "lower_95": 0, "upper_95": 0 }
  ],
  "analysis": {
    "trend": "increasing|decreasing|stable",
    "trend_strength": 0.0,
    "seasonality": {
      "detected": true,
      "pattern": "monthly|quarterly|yearly|none",
      "strength": 0.0
    },
    "volatility": "low|medium|high"
  },
  "scenarios": {
    "optimistic": { "growth_rate": 0.0, "total_forecast": 0 },
    "base": { "growth_rate": 0.0, "total_forecast": 0 },
    "pessimistic": { "growth_rate": 0.0, "total_forecast": 0 }
  },
  "insights": [
    "Insight 1",
    "Insight 2"
  ],
  "risks": [
    "Risk 1"
  ],
  "recommendations": [
    "Recommendation 1"
  ]
}`;

    // Call Gemini API
    const geminiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${geminiKey}`;
    const geminiRes = await fetch(geminiUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        contents: [{ role: 'user', parts: [{ text: prompt }] }],
        generationConfig: {
          temperature: 0.2,
          maxOutputTokens: 2048,
          responseMimeType: 'application/json'
        }
      })
    });

    if (!geminiRes.ok) {
      // Refund credits on error
      await supabase.from('user_credits').update({
        free_credits: credits.free_credits,
        paid_credits: credits.paid_credits
      }).eq('user_id', userId);
      await supabase.from('credit_transactions').insert([{
        user_id: userId,
        amount: CREDIT_COST,
        type: 'refund',
        description: 'AI ML Forecast - error'
      }]);
      throw new Error('Gemini API error');
    }

    const result = await geminiRes.json();
    const responseText = result.candidates?.[0]?.content?.parts?.[0]?.text || '{}';

    let forecast;
    try {
      forecast = JSON.parse(responseText);
    } catch {
      forecast = { error: 'Failed to parse forecast', raw: responseText };
    }

    return new Response(
      JSON.stringify({
        success: true,
        dataType,
        historicalMonths: months,
        forecastMonths,
        historicalDataPoints: historicalData.length,
        forecast
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );

  } catch (error) {
    console.error('AI ML Forecast error:', error);
    return new Response(
      JSON.stringify({ error: error.message }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});
```

## Criteres de verification
- [ ] Fichier supabase/functions/ai-ml-forecast/index.ts cree
- [ ] Verification credits (3 credits)
- [ ] Refund en cas d'erreur
- [ ] Aggregation mensuelle des donnees
- [ ] Prompt structure pour previsions
- [ ] Reponse JSON parsable

## Statut
- [ ] Complete
