# Task 010 - [MOYENNE] : AI Credit Scoring Edge Function

## Fichier(s) a creer
- `supabase/functions/ai-credit-scoring/index.ts`

## Probleme
CashPilot ne dispose pas d'un systeme de scoring credit clients base sur l'IA pour evaluer le risque de paiement.

## Solution
Creer une Edge Function utilisant Gemini pour calculer un score de credit base sur l'historique de paiement.

## Code attendu
```typescript
import { serve } from 'https://deno.land/std@0.177.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.39.3';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

const CREDIT_COST = 2;

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    const geminiKey = Deno.env.get('GEMINI_API_KEY');
    if (!geminiKey) throw new Error('GEMINI_API_KEY not configured');

    const supabase = createClient(
      Deno.env.get('SUPABASE_URL')!,
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
    );

    const { userId, clientId } = await req.json();

    if (!userId || !clientId) {
      return new Response(
        JSON.stringify({ error: 'Missing userId or clientId' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Check credits
    const { data: credits } = await supabase
      .from('user_credits')
      .select('free_credits, paid_credits')
      .eq('user_id', userId)
      .single();

    const availableCredits = (credits?.free_credits || 0) + (credits?.paid_credits || 0);
    if (!credits || availableCredits < CREDIT_COST) {
      return new Response(
        JSON.stringify({ error: 'insufficient_credits' }),
        { status: 402, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    // Deduct credits
    const freeDeduction = Math.min(credits.free_credits, CREDIT_COST);
    const paidDeduction = CREDIT_COST - freeDeduction;
    await supabase.from('user_credits').update({
      free_credits: credits.free_credits - freeDeduction,
      paid_credits: credits.paid_credits - paidDeduction,
      updated_at: new Date().toISOString()
    }).eq('user_id', userId);

    await supabase.from('credit_transactions').insert([{
      user_id: userId,
      amount: -CREDIT_COST,
      type: 'usage',
      description: 'AI Credit Scoring'
    }]);

    // Fetch client info
    const { data: client } = await supabase
      .from('clients')
      .select('*')
      .eq('id', clientId)
      .eq('user_id', userId)
      .single();

    if (!client) {
      throw new Error('Client not found');
    }

    // Fetch invoice history for this client
    const { data: invoices } = await supabase
      .from('invoices')
      .select('invoice_number, total_ttc, status, invoice_date, due_date, paid_date')
      .eq('client_id', clientId)
      .eq('user_id', userId)
      .order('invoice_date', { ascending: false })
      .limit(50);

    // Calculate payment metrics
    const paymentHistory = (invoices || []).map((inv: any) => {
      const dueDate = new Date(inv.due_date);
      const paidDate = inv.paid_date ? new Date(inv.paid_date) : null;
      const invoiceDate = new Date(inv.invoice_date);

      let daysLate = 0;
      let paymentDelay = 0;

      if (paidDate && inv.status === 'paid') {
        daysLate = Math.max(0, Math.floor((paidDate.getTime() - dueDate.getTime()) / (1000 * 60 * 60 * 24)));
        paymentDelay = Math.floor((paidDate.getTime() - invoiceDate.getTime()) / (1000 * 60 * 60 * 24));
      } else if (inv.status !== 'paid') {
        const today = new Date();
        daysLate = Math.max(0, Math.floor((today.getTime() - dueDate.getTime()) / (1000 * 60 * 60 * 24)));
      }

      return {
        invoice_number: inv.invoice_number,
        amount: inv.total_ttc,
        status: inv.status,
        invoice_date: inv.invoice_date,
        due_date: inv.due_date,
        paid_date: inv.paid_date,
        days_late: daysLate,
        payment_delay: paymentDelay
      };
    });

    // Calculate summary stats
    const paidInvoices = paymentHistory.filter((p: any) => p.status === 'paid');
    const unpaidInvoices = paymentHistory.filter((p: any) => p.status !== 'paid' && p.status !== 'draft');
    const latePayments = paidInvoices.filter((p: any) => p.days_late > 0);

    const stats = {
      total_invoices: paymentHistory.length,
      paid_invoices: paidInvoices.length,
      unpaid_invoices: unpaidInvoices.length,
      total_billed: paymentHistory.reduce((sum: number, p: any) => sum + (p.amount || 0), 0),
      total_paid: paidInvoices.reduce((sum: number, p: any) => sum + (p.amount || 0), 0),
      total_outstanding: unpaidInvoices.reduce((sum: number, p: any) => sum + (p.amount || 0), 0),
      late_payment_count: latePayments.length,
      late_payment_rate: paidInvoices.length > 0 ? (latePayments.length / paidInvoices.length * 100).toFixed(1) : 0,
      average_days_late: latePayments.length > 0
        ? (latePayments.reduce((sum: number, p: any) => sum + p.days_late, 0) / latePayments.length).toFixed(1)
        : 0,
      average_payment_delay: paidInvoices.length > 0
        ? (paidInvoices.reduce((sum: number, p: any) => sum + p.payment_delay, 0) / paidInvoices.length).toFixed(1)
        : 0
    };

    // Build prompt for Gemini
    const prompt = `Tu es un expert en analyse de credit et gestion du risque client.

Analyse cet historique de paiements client et calcule un score de credit.

CLIENT:
Nom: ${client.name}
Type: ${client.type || 'standard'}
Depuis: ${client.created_at}

STATISTIQUES DE PAIEMENT:
${JSON.stringify(stats, null, 2)}

HISTORIQUE DES 50 DERNIERES FACTURES:
${JSON.stringify(paymentHistory.slice(0, 20), null, 2)}

CRITERES D'EVALUATION:
1. Ponctualite des paiements (DSO - Days Sales Outstanding)
2. Taux de paiements en retard
3. Montants moyens vs payes
4. Tendance sur les 12 derniers mois
5. Incidents de paiement graves (>30 jours, >60 jours, >90 jours)

Reponds UNIQUEMENT en JSON valide:
{
  "score": 0,
  "rating": "A",
  "risk_level": "low",
  "dso_average": 0,
  "payment_reliability": 0,
  "trend": "stable",
  "recommended_credit_limit": 0,
  "warnings": [],
  "strengths": [],
  "recommendations": [],
  "detailed_analysis": {
    "punctuality_score": 0,
    "volume_score": 0,
    "trend_score": 0,
    "relationship_score": 0
  }
}

Echelle de score: 0-100
Ratings: A (80-100), B (60-79), C (40-59), D (20-39), E (0-19)
Risk levels: low, medium, high, critical`;

    // Call Gemini API
    const geminiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${geminiKey}`;
    const geminiRes = await fetch(geminiUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        contents: [{ role: 'user', parts: [{ text: prompt }] }],
        generationConfig: {
          temperature: 0.2,
          maxOutputTokens: 1024,
          responseMimeType: 'application/json'
        }
      })
    });

    if (!geminiRes.ok) {
      // Refund credits on error
      await supabase.from('user_credits').update({
        free_credits: credits.free_credits,
        paid_credits: credits.paid_credits
      }).eq('user_id', userId);
      await supabase.from('credit_transactions').insert([{
        user_id: userId,
        amount: CREDIT_COST,
        type: 'refund',
        description: 'AI Credit Scoring - error'
      }]);
      throw new Error('Gemini API error');
    }

    const result = await geminiRes.json();
    const responseText = result.candidates?.[0]?.content?.parts?.[0]?.text || '{}';

    let scoring;
    try {
      scoring = JSON.parse(responseText);
    } catch {
      scoring = { error: 'Failed to parse scoring', raw: responseText };
    }

    return new Response(
      JSON.stringify({
        success: true,
        client: {
          id: client.id,
          name: client.name
        },
        stats,
        scoring
      }),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );

  } catch (error) {
    console.error('AI Credit Scoring error:', error);
    return new Response(
      JSON.stringify({ error: error.message }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});
```

## Criteres de verification
- [ ] Fichier supabase/functions/ai-credit-scoring/index.ts cree
- [ ] Verification credits (2 credits)
- [ ] Calcul DSO et taux de retard
- [ ] Historique paiements du client
- [ ] Score 0-100 avec rating A-E
- [ ] Reponse JSON structuree

## Statut
- [ ] Complete
